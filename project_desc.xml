<?xml version="1.0" encoding="ISO-8859-1"?>
<projects>

<!--RoR : Hostile Worlds-->
<project id="ror">
	<name>Risk of Rain : Hostile Worlds</name>
	<image>images/work/zs.png</image>
	<screenshots>
		<screenshotImg>images/screenshots/ror/0.gif</screenshotImg>
		<screenshotImg>images/screenshots/ror/1.gif</screenshotImg>
		<screenshotImg>images/screenshots/ror/2.gif</screenshotImg>
		<screenshotImg>images/screenshots/ror/3.gif</screenshotImg>
	</screenshots>
	<description lang="fr">
	<![CDATA[
	Risk of Rain : Hostile Worlds est une déclinaison mobile de la saga Risk of Rain s'inscrivant entre les deux premiers opus.<br />
	Il s'agit d'un rogue-like possédant un mode campagne et un mode coop. Au fil des missions nous pouvons obtenir de nouveaux survivants, de l'équipement et toutes sortes d'améliorations pour nos personnages. <br />
	La rejouabilité était assurée par la présence de différents modes de difficultés, et par le coté aleátoire des missions / zones dans lesquelles on devait évoluer. <br />
	Au niveau technique, le jeu était développé sous Unity et avec le moteur multijoueur Photon Quantum. <br />
	
	Je me suis occupé de plusieurs morceaux dont voici les principaux : <br />
	<ul class="bulletedlist">
		<li><b>Le système d'objectifs : </b></li>
		Bâti du côté de Quantum, ce système permettait d'avoir des objectifs consitutés de tâches que l'on pouvait compléter en ordre fixe ou de manière plus libre. <br />
		Je l'ai rendu le plus modulaire possible afin de pouvoir rajouter facilement différents types d'objectifs et de tâches. <br />
		Côté tooling, j'ai travaillé sur un outil qui permettait in-fine aux game designers de construire facilement leur liste d'objectifs / tâches et les paramètres qui vont avec. <br />
		
		<li><b>L'économie du jeu : </b></li>
		Un magasin permettait d'acheter des monnaies, des objets ou personnages en échange d'argent virtuel ou réel (IAP). <br />
		Il y avait également un magasin de type "gacha" où l'on pouvait utiliser des monnaies pour ouvrir des lootboxes donnant des personnages ou des items d'amélioration pour ces derniers. <br />
		Le backend reposait sur Playfab et sur des fonctions Azure. </br>
		J'ai intégré la totalité du flow pour ces deux features : un outil qui permet aux designers de gérer l'intégralité du contenu du shop et des gachas puis de les déployer sur Playfab, la logique pour les achats côté Unity et Azure Functions, et l'intégration du UI.
		
		<li><b>Mode de jeu "Trials" : </b></li>
		Dans le jeu nous avions un outil / système de quêtes permettant d'avoir différents types de quêtes (quotidiennes, hebdomadaire, succès...). <br />
		De ce système, j'en ai crée un dérivé permettant de gérer un mode de jeu nommé Trials consistant à accomplir des missions le plus rapidement possible pour avoir des récompenses attribuées selon le temps de jeu. <br />
		Chaque trial est une quête qui n'est visible qu'à certains moments (durant un évènement par exemple) et qui n'est pas affichée avec les autres quêtes, mais dans un UI dédié.
		
		<li><b>Tooling divers : </b></li>
		J'ai réalisé des outils permettant aux game designers de manipuler certains éléments ou paramètres du jeu (contenu des coffres, taux d'apparitions d'évènements, import de données...)
	</ul>
	
	]]>
	</description>
	
	<description lang="en">
	<![CDATA[
	Risk of Rain: Hostile Worlds is a mobile spin-off of the Risk of Rain saga, set between the first two installments.<br />
	It is a rogue-like featuring a campaign mode and a co-op mode. Throughout the missions, players can unlock new survivors, equipment, and various upgrades for their characters. <br />
	Replayability was ensured through the inclusion of different difficulty levels and the randomness of missions/zones to explore. <br />
	From a technical perspective, the game was developed using Unity and the Photon Quantum multiplayer engine. <br />
	
	I worked on several aspects of the game, including the following key contributions: <br />
	<ul class="bulletedlist">
		<li><b>The objective system: </b></li>
		Built on Quantum, this system allowed for objectives consisting of tasks that could be completed either in a fixed order or more freely. <br />
		I made it as modular as possible to easily add various types of objectives and tasks.<br />
		On the tooling side, I developed a tool that allowed game designers to easily construct their list of objectives/tasks and associated parameters. <br />
		
		<li><b>Game economy: </b></li>
		A shop allowed players to purchase currencies, items, or characters using virtual or real money (IAP). <br />
		There was also a "gacha"-style shop where currencies could be used to open loot boxes that granted characters or upgrade items for them. <br />
		The backend relied on PlayFab and Azure functions. <br />
		I implemented the entire flow for these two features: a tool for designers to manage the shop and gacha content and deploy it to PlayFab, the logic for purchases in Unity and Azure Functions, and the UI integration.
		
		<li><b>Game mode "Trials": </b></li>
		The game included a quest system allowing for various types of quests (daily, weekly, achievements, etc.). <br />
		I created a derivative system to manage a game mode called Trials, which involved completing missions as quickly as possible to earn rewards based on time. <br />
		Each trial is a quest visible only at specific times (e.g., during an event) and displayed in a dedicated UI separate from other quests.
		
		<li><b>Various tooling: </b></li>
		I developed tools enabling game designers to manipulate specific game elements or parameters (chest contents, event spawn rates, data imports, etc.).
	</ul>
	
	]]>
	</description>
	
	<links>
		<link name="youtube">TolpGVuJQZw</link>
	</links>
</project>

<!--Harry Potter Wizards Unite-->
<project id="hpwu">
	<name>Harry Potter : Wizards Unite</name>
	<image>images/work/hpwu.png</image>
	<screenshots>
		<screenshotImg>images/screenshots/hpwu/0.gif</screenshotImg>
		<screenshotImg>images/screenshots/hpwu/1.png</screenshotImg>
		<screenshotImg>images/screenshots/hpwu/2.png</screenshotImg>
	</screenshots>
	<description lang="fr">
	<![CDATA[
	Harry Potter : Wizards Unite est un jeu mobile développé par Niantic et Warner Bros Games, et supporté en partie par Frima pour le développement LiveOps.<br />
	Il s'agit d'un jeu en réalité augmentée similaire à Pokémon Go, où le joueur peut se promener dans la vraie vie afin de croiser des personnages de l'univers d'Harry Potter, de combattre des créatures ou encore de dénicher
	des objets magiques dans l'environnement. <br />
	Certaines séquences, comme les combats, se déroulent en RA. Il faut alors orienter la caméra pour trouver l'adversaire où la créature rencontrée, et effectuer différents gestes pour lancer des sorts.
	
	Sur ce projet, j'ai principalement travaillé sur développement de certaines updates et leur déploiement : <br />
	<ul class="bulletedlist">
		<li><b>Combats contre des ennemis spéciaux :</b></li>
		En reprenant le système de combats existant, nous avons ajouté une petite couche de gameplay similaire à des instances / donjons que l'on peut trouver dans un MMORPG.<br />
		On entre dans une instance où le but sera de défaire un certain nombre d'ennemis le plus vite possible par exemple.
		
		<li><b>Déploiement de mises à jours : </b></li>
		Pas une feature à proprement parler, mais il s'agissait de s'occuper de la partie Live Ops / déploiement des nouvelles mises à jour et des patchs en utilisant le pipeline mis en place par Niantic et WB Games.
		
		<li><b>Intégration d'un plugin de chat social : </b></li>
		Niantic souhaitait tester l'ajout d'un système de chat social dans le jeu afin de l'intégrer éventuellement sur d'autres titres. <br />
		Je me suis donc occupé d'intégrer ce plugin et la partie UI qui permettait d'y accéder.
	</ul>
	
	]]>
	</description>
	
	<description lang="en">
	<![CDATA[
	Harry Potter: Wizards Unite is a mobile game developed by Niantic and Warner Bros Games, for which Frima did LiveOps support.<br />
	It's an AR game similar to Pokémon Go, where players can explore the real world to encounter characters from the Harry Potter universe, battle creatures, or find magical objects in their surroundings. <br />
	Certain sequences, such as battles, take place in AR. Players must rotate their camera to find the opponent or creature encountered and perform various gestures to cast spells.
	
	On this project, I have primarily worked on the development of updates and the live ops support : <br />
	<ul class="bulletedlist">
		<li><b>Battles against special enemies :</b></li>
		Reusing the existing combat system, we've added a small gameplay layer similar to instances/dungeons found in MMORPGs. <br />
		Players enter an instance where the goal can be to defeat a certain number of enemies as quickly as possible, for example.
		
		<li><b>Deployment of updates : </b></li>
		Not a feature per se, but it involved handling the Live Ops / deployment of new updates and patches using the pipeline set up by Niantic and WB Games.
		
		<li><b>Social chat plugin integration : </b></li>
		Niantic wanted to test the addition of a social chat system in the game with the possibility of integrating it into other titles.<br />
		I handled the integration of this plugin and the UI component that provided access to it.
	</ul>
	
	]]>

	</description>
	
	<links>
		<link name="youtube">Odv4OR24S_s</link>
	</links>
</project>

<!--ZS Redeemed edition -->
<project id="zs">
	<name>Zombie Survival : Redeemed Edition</name>
	<image>images/work/zs.png</image>
	<screenshots>
		<screenshotImg>images/screenshots/zs/0.png</screenshotImg>
		<screenshotImg>images/screenshots/zs/1.png</screenshotImg>
		<screenshotImg>images/screenshots/zs/2.png</screenshotImg>
		<screenshotImg>images/screenshots/zs/3.png</screenshotImg>
	</screenshots>
	<description lang="fr">
	<![CDATA[
	Zombie Survival est un mod multijoueur pour le jeu Garry's Mod (PC) dans lequel des humains doivent survivre face à des zombies.<br />
	En tant qu'humain, vous pouvez obtenir de nouvelles armes en tuant des zombies, et en tant que zombie, éliminer des humains permet de débloquer de nouvelles classes. <br />
	Avec suffisamment d'humains tués, un zombie peut ressusciter et reprendre le combat. <br /><br />
	A l'origine le mod avait un gameplay de type gun and run / arcade, mais la version principale du jeu s'est depuis orientée sur un aspect survie / barricade plus poussé.<br />
	Redeemed Edition en est une réecriture complète, visant à retourner à un gameplay arcade avec ses particularités. De futurs ajouts viendront bonifier son contenu. <br /><br />
	
	Avec ce projet développé entièrement en LUA, je me suis lancé pour défi de faire revivre ce jeu qui m'avait occupé durant de nombreuses soirées il y a fort longtemps ! <br />
	Le fait que ce soit un mod et non un jeu "standalone" permet de m'affranchir des contraintes artistiques et des problématiques liées au jeu en réseau : le jeu me fournit les outils et le contenu nécessaire pour cela. <br />
	Je me suis occupé de l'intégralité du développement en m'aidant d'un ancien code fait par Clavus, Ywa et Deluvas - anciens développeurs de la communauté Mr Green Gaming qui héberge le mod - et du code plus récent fait par Jetboom, le créateur du mod original. <br />
	L'ancien code étant déprécié et non fonctionnel, et le nouveau étant trop différent de ce que je voulais faire, j'ai choisi de partir de zéro en m'inspirant du premier et en prenant les outils nécessaires issus du second pour le faire fonctionner. <br /><br />

	Le projet, débuté en 2020, est toujours en cours de développement, et voici les principaux travaux accomplis à ce jour : <br />
	<ul class="bulletedlist">
		<li>Gameplay des humains et des zombies</li>
		<li>Mécaniques principales (déblocage des armes, déblocage des classes, résurrection des zombies)</li>
		<li>Système de "perks" par arme : plus on utilise une arme, plus celle-ci s'améliore (dégâts bonus, munitions, soins etc). Ces perks ne sont valides que pour la partie en cours.
		<li>Interface utilisateur et menus de choix de classe et d'options</li>
		<li>Backend et "Services" permettant de gérer l'information des joueurs (scores, temps joué etc) et leur inventaire</li>
		<li>Magasin in-game permettant d'acheter des améliorations et des objets cosmétiques</li>
		<li>Système de missions quotidiennes et de succès</li>
		<li>Joueurs bots (librairie DRGBase) : la librairie fournit des comportements de base auxquels j'ai rajouté les éléments particuliers de ZS.</li>
	</ul>
	<br />
	
	Pour accéder au Github du jeu, contactez moi.<br />
	]]>
	</description>
	
	<description lang="en">
	<![CDATA[
	Zombie Survival is a multiplayer mod for the game Garry's Mod (PC) where humans must survive against zombies.<br />
	As a human, you can obtain new weapons by killing zombies, and as a zombie, eliminating humans allows you to unlock new classes. <br />
	With enough humans killed, a zombie can respawn and rejoin the fight. <br /><br />
	Originally, the mod had a gun-and-run/arcade-style gameplay, but the main version of the game has since shifted towards a more survival/barricade-focused approach.<br />
	Redeemed Edition is a complete rewrite aimed at returning to an arcade gameplay style with its unique features. Future updates will further enhance its content. <br /><br />
	
	Developed entirely in LUA, I challenged myself with this project to revive the game that kept me entertained for many evenings a long time ago! <br />
	The fact that it's a mod and not a standalone game frees me from artistic constraints and networking issues: the game provides the necessary tools and content. <br />
	I handled the entirety of the development, drawing on old code by Clavus, Ywa, and Deluvas-former developers from the Mr Green Gaming community that hosted the mod-and newer code by Jetboom, the original creator of the mod. <br />
	With the old code being deprecated and non-functional, and the new code being too different from what I wanted to achieve, I chose to start from scratch, drawing inspiration from the former and using necessary tools from the latter to make it work. <br /><br />

	Started in 2020, the project is still in development. Here are the main tasks accomplished to date: <br />
	<ul class="bulletedlist">
		<li>Gameplay for humans and zombies</li>
		<li>Core mechanics (weapon unlocks, class unlocks, zombie resurrection)</li>
		<li>Weapon perk system: the more you use a weapon, the more it improves (bonus damage, ammunition, healing, etc.). These perks are only valid for the current session.</li>
		<li>User interface and class/option selection menus</li>
		<li>Backend and "services" for managing player information (scores, playtime, etc.) and their inventory</li>
		<li>In-game shop for purchasing upgrades and cosmetic items</li>
		<li>Daily missions and achievement system</li>
		<li>Bot players (DRGBase library): the library provides basic behaviors, to which I added the unique elements of ZS.</li>
	</ul>
	<br />
	
	Contact me if you wish to access the game's Github. <br />
	]]>
	</description>
	
	<links>
		<link name="github">https://github.com/yannismrad/zombiesurvivalrevamped</link>
		<link name="youtube">Gu0wtAujWf4</link>
	</links>
</project>

<!--Gonzuela -->
<project id="gonz">
	<name>Gonzuela</name>
	<image>images/work/gonz.png</image>
	<screenshots>
		<screenshotImg>images/screenshots/gonz/0.png</screenshotImg>
		<screenshotImg>images/screenshots/gonz/1.png</screenshotImg>
		<screenshotImg>images/screenshots/gonz/2.png</screenshotImg>
	</screenshots>
	<description lang="fr">
	<![CDATA[
	Gonzuela est le jeu que notre équipe, Psycho Mantisse, a développé durant le Pixel Challenge 2018. <br />
	Le thème de cette gamejam était "La tempête parfaite".<br />
	Un joueur incarne Gonzuela, une mamie devant entretenir / nettoyer la maison, tandis qu'un autre joueur incarne trois enfants devant y semer la pagaille !<br />
	Ils doivent en effet casser un maximum de choses pour faire monter une jauge de "Chaos" (représentant l'état de la maison) que Gonzuela doit faire descendre en nettoyant / réparant les objets cassés.<br />
	A la fin du chrono, Gonzuela gagne si la maison est suffisament propre, sinon les enfants gagnent ! <br /><br />
	
	Sur ce jeu je me suis occupé de plusieurs parties du gameplay, du côté des enfants principalement, à savoir leur gameplay en général et leurs interactions avec les différents objets du décor. <br />
	À tout moment, le joueur a la possibilité d'alterner entre les trois enfants : deux des enfants sont alors contrôlés par une IA qui va, de manière aléatoire, les faire se promener dans la maison.<br />
	À certains moments (aléatoires aussi), un enfant IA se dirigera vers un objet et provoquera une interaction avec celui-ci. 
	Lors de l'interaction, l'enfant IA restera un certain temps à coté de l'objet pour simuler l'interaction (lorsque le joueur interagit avec quelque chose, l'action prend un certain temps). <br />
	
	J'ai également pris soin de gérer l'ouverture automatique des portes lorsqu'un personnage s'en approche (un peu comme dans le jeu Les Sims) <br />
	
	]]>
	</description>
	
	<description lang="en">
		<![CDATA[
	Gonzuela is a 2-players versus game made by team Psycho Mantisse for the Pixel Challenge 2018. <br />
	The theme was "The perfect storm". <br />
	One player is Gonzuela, a housemaid whose role is to keep the house clean and to repair any thing that the kids, controlled by the other player, break. <br />
	The storm is represented by the accumulation of bad events happening at the same time in the house, which forces Gonzuela to clean or repair stuff that the kids have broken. <br />
	The "chaos bar" on the top shows how chaotic the house is. <br />
	At the end of the timer, Gonzuela wins if she could keep the house relatively clean (she holds most of the chaos bar). The kids win otherwise.<br /><br />
	
	For this game, I have mainly worked on the gameplay parts related to the kids : their gameplay in general, and the way they interact with all the items placed on the stage. <br />
	At any time, the player can switch between the three kids : two of them are controlled by an AI that will make them wander in the house in a random way. <br />
	Also, an AI kid will head to an item's location and iteract with it for a certain amount of time (as the player, interacting with an item takes some time, so we're simulating this for the AI player) <br />
	On a side note, I also took care of how the doors are opened-closed when a character gets close (like in The Sims game). <br />
	
	]]>
	</description>
	
	<links>
		<link name="github">https://github.com/Pixel2018Team/Pixel2018Game</link>
		<link name="youtube">GgNAsi602no</link>
	</links>
</project>

<!--Shade -->
<project id="shade">
	<name>Shade</name>
	<image>images/work/shade.png</image>
	<screenshots>
		<screenshotImg>images/screenshots/shade/0.png</screenshotImg>
		<screenshotImg>images/screenshots/shade/1.png</screenshotImg>
		<screenshotImg>images/screenshots/shade/2.png</screenshotImg>
	</screenshots>
	<description lang="fr">
	<![CDATA[
	Shade est un puzzle-game coopératif développé durant le Pixel Challenge 2017, en compagnie des membres de l'équipe Silly Hat. <br />
	Deux joueurs doivent traverser différents niveaux en colorant des tuiles afin de créer un chemin empruntable par l'un ou l'autre des joueurs selon leur couleur. <br />
	Le joueur blanc peut ainsi peindre des tuiles en noir pour faire avancer le joueur noir, et vice versa. <br />
	Il faudra parfois activer certains mécanismes pour progresser, et éviter des obstacles, ce qui requiert une certaine coordination et de la rapidité ! <br />
	<br />
	
	Sur ce projet, je me suis occupé d'un côté de l'organisation (créer le github, gérer la manière dont nous allions nous partager les ressources) et de l'autre de la partie gameplay. <br />
	Je me suis intéressé notamment aux interactions entre les deux personnages et les objets nécessaires permettant de finir un niveau (boutons, zones à atteindre).<br />
	La plupart du temps, l'interaction repose sur une détection de collision pour l'un ou l'autre ou les deux joueurs (ex : deux joueurs en meme temps sur deux boutons, ou un seul des deux qui appuie sur un bouton pour ouvrir la voie à l'autre).<br />

	Une autre feature que j'avais rajoutée était la présence de lasers en mouvement qui devaient entraîner le game over au contact de l'un des joueurs, mais elle n'etait pas entièrement finie à la fin de la jam. <br />
	A côté, je me suis également occupé un peu du lightmapping / illumination globale des niveaux.

	]]>
	</description>
	
	<description lang="en">
		<![CDATA[
	Shade is a 2-players Coop-puzzle game developed during the Pixel Challenge 2017 with the Silly Hat team.
	Players have to reach the end of the levels by painting a path which can be crossed by their mate.
	Thus, the white player can only paint tiles in black, and vice versa.<br />
	Both players must trigger buttons and avoid obstacles in a synchronous way ! <br />
	<br />
	
	On this game, I've taken care of the upstream organization (creating the github, managing the way we would share the game assets) and some parts of the gameplay. <br />
	I've worked on the interactios between the two characters and the different objects needed to finish a level (buttons, collision areas). <br />
	Most of the time, these interactions rely on a collision detection for either one or the other or both players (eg : two players pushing two buttons at the same time, or one of them pushing a button which unlocks the path for the other).<br />
	
	Another feature that I haven't had time to finished at the end of the jam was the presence of lasers that caused a game over whenever a player was hit. <br />
	
	Besides, I also worked on the lightmapping / Global illumination for the different levels.
	]]>
	</description>
	
	<links>
		<link name="github">https://github.com/SillyHatStudio/Pixel2017</link>
		<link name="youtube">mLhRqZcTa3w</link>
	</links>
</project>

<!--Gazeduc / GRT Gaz -->
<project id="grtgaz">
	<name>Gazeduc (GRTgaz)</name>
	<image>images/work/grtgaz.png</image>
	<screenshots>
		<screenshotImg>images/screenshots/grtgaz/0.png</screenshotImg>
		<screenshotImg>images/screenshots/grtgaz/1.png</screenshotImg>
		<screenshotImg>images/screenshots/grtgaz/2.png</screenshotImg>
	</screenshots>
	<description lang="fr">
	<![CDATA[
	Gazeduc est une application en réalité virtuelle développée par MiddleVR pour GRTgaz (filiale du groupe ENGIE) sur laquelle j'ai travaillé durant mon stage de Master 2. <br />
	C'est une application développée sous Unity, fonctionnant sous HTC Vive,  qui a pour objectif de former des techniciens aux opérations sur des postes de détente de gaz.<br />
	Elle comporte une simulation physique réaliste de la pression du gaz en différents points de l'installation, l'aspect VR permet de manipuler différents éléments permettant
	d'agir sur cette simulation. <br />
	La manipulation, de type main virtuelle, permet par exemple d'ouvrir des robinets, des vannes et de saisir des manomètres. <br /><br />
	
	Je me suis occupé de travailler sur la navigation de l'utilisateur, qui repose sur la présence d'une zone en pointillés au sol. <br />
	Comme le projet était concu pour être utilisé avec le HTC Vive, l'idée de cette zone était que si la personne se déplacait vers une bordure, celle-ci glisserait doucement dans la direction choisie. <br />
	C'est comme une plateforme que nous pouvons parcourir à pieds et faire se déplacer dans quatre directions. <br />
	Le déplacement de la zone se fait graduellement : plus on pénètre loin dans la bordure, plus la vitesse de déplacement - symbolisée par un vecteur au sol - sera rapide. <br /><br />
	
	Par ailleurs, j'ai mis en place un tutoriel qui permet à un utilisateur d'apprendre les différents gestes permettant de manipuler l'equipement et les appareils du poste de détente de gaz.<br />
	À chaque étape, il nous est demandé d'effectuer un geste. Celui-ci est alors validé en vérifiant si il a été effectué entièrement (en vérifiant par exemple l'angle de rotation d'une valve, ou si un objet est placé au bon endroit). <br />
	]]>
	</description>
	
	<description lang="en">
		<![CDATA[
	Gazeduc is a VR application developed by MiddleVR for GRTgaz I have been working on during my Master2's internship. <br />
	Developed with Unity for the HTC Vive, it is a training application that teaches engineers how to operate on specific gas distribution facilities. <br />
	With VR, you can safely interact with various elements to modify the realistic gas simulation running behind. <br />

	Direct virtual hand manipulation allows you to manipulate the different objects (taps, valves, manometers etc). <br /><br />
	
	I have worked on the user navigation, which relies on a tracking area displayed on the floor. <br />
	You can walk inside this area, and when you reach an edge, the area will slowly start to "slide" in the chosen direction, as if you were on a moving platform.  <br />
	The farther you are into the border of the platform, the faster it will move (speed is represented by a vector drawn on the floor). <br />
	
	In addition to this, I have worked on a tutorial that allows a user to learn the different gestures that he will have to use un order to handle the facility's equipment. <br />
	Each of the tutorial's steps require you to make a specific gesture in order to have a specific result (e.g.: turning a valve handle in a particular angle, or check if an object is plugged into the gas system).<br />

	]]>
	</description>
	
	<links>
		<link name="youtube">996t5RGh-WE</link>
	</links>
</project>

<!--Shadow 2 -->
<project id="vrs2">
	<name>Shadow 2 (VR)</name>
	<image>images/work/vrs2.png</image>
	<screenshots>
		<screenshotImg>images/screenshots/vrs2/0.png</screenshotImg>
		<screenshotImg>images/screenshots/vrs2/1.png</screenshotImg>
		<screenshotImg>images/screenshots/vrs2/2.png</screenshotImg>
	</screenshots>
	<description lang="fr">
	<![CDATA[
	Shadow 2 est une application que j'ai développée durant mon stage chez MiddleVR et qui vise à présenter différentes fonctionnalités du plugin 
	MiddleVR pour Unity. L'idée est de se promener dans un appartement pour intéragir avec les objets qui s'y trouvent, en proposant différentes manières d'interagir. <br /><br />
	
	J'ai eu carte blanche pour proposer diverses expériences et interactions intéressantes, alors j'ai mis en place une série d'activités simples à réaliser 
	et qui permettent de montrer une partie de ce que l'on peut faire en VR. <br />
	Comme l'appartement comporte plusieurs pièces, j'ai implémenté une navigation de type World in Miniature : On dispose d'une maquette de l'appartement que l'on peut saisir comme une carte. <br />
	En cliquant sur une sphère, on se téléporte alors vers la pièce choisie.<br />
	La maquette étant une version miniature de la scène réelle, on ne risque pas de se perdre puisque l'on peut idenfitier facilement l'endroit où nous nous trouvons. <br /><br />
	
	Au niveau des manipulations, il est possible de manipuler des objets à une et/ou deux mains de facon naturelle (mapping direct : une manette représente une main). <br />
	Par exemple, on peut saisir des objets et les lancer, prendre un crayon et dessiner, naviguer sur une télévision à écran "tactile" ou encore jouer de la guitare à deux mains. <br />
	
	]]>
	</description>
	
	<description lang="en">
		<![CDATA[
	Shadow 2 is a VR application that I have developed during my internship at MiddleVR.
	Its goal is to show different functionnalities provided with the MiddleVR For Unity plugin. <br/>
	In this application, you can explore a flat and interact with several items, with different types of interaction. <br /><br />

	I have implemented various activites and interactions that were meant to be simple to execute and that show what VR allows you to do. <br />
	As the flat is composed of multiple rooms, I've chosen to implement a World in Miniature navigation : using a miniature model of the flat, you can freely navigate between the rooms by clicking on spheres above them. <br />
	
	Manipulations were made so some objects could be used with one hand or both, as you would do in real life (direct mapping is used here, that means your Vive controllers are your virtual hands). <br />
	You can for example grab objects and throw them, take a pen and draw on a board, surf the internet on a touchscreen TV or play guitar with your two hands. <br />
	]]>
	</description>
	
	<links>
		<link name="youtube">2ogBzicLGBs</link>
	</links>
</project>

<!--fly or die -->
<project id="fod">
	<name>Fly or Die</name>
	<image>images/work/fod.png</image>
	<screenshots>
		<screenshotImg>images/screenshots/fod/0.png</screenshotImg>
		<screenshotImg>images/screenshots/fod/1.png</screenshotImg>
		<screenshotImg>images/screenshots/fod/2.png</screenshotImg>
	</screenshots>
	
	<description lang="fr">
	<![CDATA[
	Fly or Die est un jeu de duel asymétrique "homme VS mouche" en réalité virtuelle développé sous Unity à l'occasion de la GlobalGameJam 2016.
	Un joueur contrôle une mouche à la manette tandis qu'un autre utilise un casque et un wand (HTC Vive) pour la chasser.
	Le but de la mouche est de s'enfuir par la fenêtre tandis que le joueur au Vive doit l'écraser avec sa tapette !
	<br /><br />
	
	Je m'etais occupé d'une partie du gameplay côté humain, avec notamment les interactions au niveau de la tapette ainsi que l'ajout de pots de confiture pouvant servir de pièges : <br />
	En cassant un pot, la confiture se répand au sol. Si la mouche se pose dessus, elle reste bloquée quelques secondes. <br />

	J'ai également travaillé sur le côté UI / images pour réaliser quelques images et menus explicatifs. <br />
	]]>
	</description>
	
	<description lang="en">
		<![CDATA[
	Fly or Die is an asymetrical VR duel game developed during the GlobalGameJam 2016, using Unity.
	A player controls a fly with a gamepad while the other uses an HMD and a wand (HTC Vive for example) as a fly swatter.
	Fly player's goal is to escape through the window while the human has to kill him !
	<br />

	I've worked on some parts of the gameplay related to the swatter interactions, and adding jam pots that could be used as traps : <br />
	Breaking a jam pot would spill its content on the floor. If the fly gets too close, it would be stuck there for a short time. <br />
	
	I've also worked on the UI / menus by making a few tutorial pictures and menu elements. <br />
	]]>
	</description>
	
	<links>
		<link name="youtube">lhx2ZeM5064</link>
	</links>
</project>

<!--Cubic run -->
<project id="cr">
	<name>Cubic Run</name>
	<image>images/work/cr.png</image>
	<screenshots>
		<screenshotImg>images/screenshots/cr/0.png</screenshotImg>
		<screenshotImg>images/screenshots/cr/1.png</screenshotImg>
		<screenshotImg>images/screenshots/cr/2.png</screenshotImg>
	</screenshots>
	<description lang="fr">
	<![CDATA[
	Cubic Run est un Endless Runner développé sous Unity pour le cours de Développement d'extensions logicielles, en Master 2 ISICG. <br />
	Le but est de sauter de plateforme en plateforme pour récolter des orbes tout en évitant des obstacles et en fuyant un monstre cubique qui dévore les plateformes sur son chemin.
	<br /><br />
	
	Celles-ci sont des préfabs qui sont stockés dans une pool / liste. Elles sont choisies aléatoirement lors de leur apparition, et une fois "mangées" par le monstre elles sont remises en pool. <br />
	Le personnage se dirige a la souris, en cliquant en continu pour qu'il se dirige vers l'endroit choisi. (On projette alors les coordonnées 2D du clic dans l'espace 3D pour déterminer l'endroit où il faut aller). <br />
	Si le personnage tombe, touche des blocs rouges ou se fait manger (colliders) c'est le game over. <br />
	
	Une feature que j'ai rajoutée est l'accéleration du rythme de jeu lorsque le joueur récolte suffisamment d'orbes : les plateformes défilent de plus en plus vite et sont de plus en plus compliquées, le monstre ouvre et ferme sa mâchoire plus vite 
	et la musique change pour rendre la situation plus stressante ! <br />

	]]>
	</description>
	
	<description lang="en">
	<![CDATA[
	Cubic Run is an endless runner game that I have made with Unity for the software plugin course during my Master 2 ISICG. <br />
	The goal is to run and jump over the platforms, collect orbs that increase your score and avoid obstacles and a cubic monster that is chasing you and eating the platforms on his way. <br /><br />
	
	Those are prefabs that are stored in a pool. They are randomly chosen, and once they are "eaten" by the monster, they go back to the pool. <br />
	The character is controlled with the mouse. Holding the mouse click makes him go to the chosen point (we transform the mouse 2D coordinates into 3D coordinates to have said point). <br />
	If you fall, touch red blocks or get eaten by the monster (collider checks), you lose ! <br /><br />
	
	Another feature that I have added to make the game more dynamic is a pace that changes according to the player score : platforms move faster and are more complicated, the monster's jaws are chewing faster and the music changes as well. <br />
	
	]]>
	</description>
	
	<links>
	</links>
</project>

<!--serious game to learn maths -->
<project id="sgtlm">
	<name>Serious Game to Learn Maths</name>
	<image>images/work/sgtlm.png</image>
	<screenshotFolder></screenshotFolder>
	<description lang="fr">
	<![CDATA[
	Serious game réalisé dans le cadre du cours Interaction 3D et Réalité Virtuelle de l'UQAC. <br />
	On contrôle ici un robot qui doit résoudre une série d'énigmes afin de réparer différentes parties de son vaisseau spatial. <br />
	Un bras haptique (Novint Falcon) est utilisé dans le cadre de ce jeu afin de contrôler le robot, de manipuler des éléments interactifs et de ressentir les forces de contact.<br />
	Les énigmes sont composées de notions de mathématiques de niveau secondaires, et les réponses sont obtenues en manipulant certains objets, d'où l'aspect serious-game du jeu. <br />
	<br /><br />

	J'ai travaillé principalement sur des mécaniques de gameplay, et notamment la manipulation des objets à l'aide du bras haptique. <br />
	Il y avait tout d'abord le fait de saisir/lâcher des objets (pour les placer à des endroits précis), la rotation d'autres objets (ex: faire tourner une roue pour aligner une valeur donnée) et la logique de validation des énigmes en général. <br />
	
	]]>
	</description>
	
	<description lang="en">
		<![CDATA[
	Serious game developed for the 3D interaction & Virtual Reality course (UQAC).  <br />
	We play as a robot that must solve enigmas in order to repair his broken spaceship.  <br />
	An haptic device (Novint Falcon) is used to manipulate interactive game elements and feel various forces.  <br />
	Enigmas are actually math problems (secondary level) that have to be solved by manipulating specific objects to find the correct answers, hence the serious-game aspect. <br /><br /> 
	
	I have worked on the gameplay elements, especially the object manipulation with the haptic device such as grabbing/dropping objects (to place them on specific spots), rotation (e.g.: rotating a wheel to align a value written on it) and the validation logic in general.  <br />

	]]>
	</description>
	
	<links>
		<link name="github">https://github.com/Shask/VR-Serious-Game-to-learn-math</link>
		<link name="youtube">fNsQpMriEtY</link>
	</links>
</project>

<!--mid term exam -->
<project id="mte">
	<name>MidTerm Exam</name>
	<image>images/work/mte.png</image>
	<screenshots>
		<screenshotImg>images/screenshots/mte/0.png</screenshotImg>
		<screenshotImg>images/screenshots/mte/1.png</screenshotImg>
		<screenshotImg>images/screenshots/mte/2.png</screenshotImg>
	</screenshots>
	<description lang="fr">
	<![CDATA[
	Midterm Exam est un jeu réalisé durant la WonderJam hiver 2015 à l'UQAC. <br />
	Il s'agit d'un jeu de tir rythmique en 2,5D répondant au thème "Plus de peur que de mal".<br />
	On incarne un professeur un peu stressé qui surveille un examen. Les étudiants ont tendance à vouloir copier sur leurs voisins, jouer avec leur téléphone ou encore faire du bruit, ce qui fait stresser encore plus le professeur. <br />
	Son unique solution pour se détendre : lancer des craies sur les étudiants agités ! <br />
	Plus l'agitation générale augmente, plus le stress s'intensifie. Il faut alors se dépêcher de tirer des craies pour faire redescendre le stress. <br />
	Tirer sur un étudiant agité fait gagner des points, mais viser un innocent en fait perdre ! <br />
	
	Sur ce jeu, notre équipe était constituée de 5 programmeurs et une artiste.<br /><br />
	
	J'ai travaillé pour ma part sur plusieurs parties du gameplay. <br />
	Le placement des élèves dans la classe qui est configurable (on peut choisir le nombre maximum d'élèves et leur disposition).<br />
	J'ai rajouté aussi différents feedbacks (sonores principalements) lorsque l'on tire et que l'on touche des élèves. <br />
	Pour faire varier la dynamique du jeu, j'ai également travaillé sur une musique qui s'adapte au niveau de stress : plus celui-ci est élevé, plus la musique s'intensifie. <br />
	Enfin, je me suis occupé de l'interface graphique et des différents menus à l'aide du travail de notre artiste. <br />
	

	]]>
	</description>
	
	<description lang="en">
	<![CDATA[
	Midterm Exam is a game that has been made during the 2015 Winter WonderJam at UQAC. <br />
	It's a rythmical shooter game that matches the following theme : "More fear than harm". <br />
	We play as a teacher that is watching an exam. Students are prone to cheat, play with their cell or make noise, which is stressful for the teacher. <br />
	His unique solution to destress is to throw chalks at the students ! <br />
	The more students are disturbing the exam, the higher the stress goes. You must be quick and shoot chalks to lower the stress level as fast as possible ! <br />
	
	For this game, our team was composed of five developers and an artist.<br /><br />
	
	I have worked on parts of the gameplay, including the students' spawning system  (you can choose their position, the general setting of the classroom), and the different feedbacks (sounds) when we shoot chalks and hit student. <br />
	Also, to make the gameplay more dynamic, I've added a dynamic music that changes with the stress level : the higher the stress goes, the more intense the music is. <br />
	At last, I've also worked on the UI and menus with the help of our artist. <br />
	
	]]>
	</description>
	
	<links>
		<link name="github">https://github.com/Steguer/GreatParanoidTeacher</link>
		<link name="youtube">wYGmvll690Q</link>
	</links>
</project>

<!--daynight killer -->
<project id="dnk">
	<name>DayNight Killer</name>
	<image>images/work/dnk.png</image>
	<screenshots>
		<screenshotImg>images/screenshots/dnk/0.png</screenshotImg>
		<screenshotImg>images/screenshots/dnk/1.png</screenshotImg>
	</screenshots>
	
	<description lang="fr">
	<![CDATA[
		Daynight killer est un petit jeu développé dans le cadre du cours de Conception de jeux vidéos à l'UQAC.
		Il s'agit d'un survival asymétrique que nous avons réalisé en équipe de trois, avec le moteur Unity.<br /> 
		
		Des villageois doivent survivre à un démon qui rôde dans leur village durant une nuit (quelques minutes en jeu). <br /> 
		S'ils survivent jusqu'à l'aube, ils pourront l'éliminer à l'aide de pouvoirs magiques. <br /> 
		
		On peut incarner soit un villageois (les autres étant des IA), soit le démon. <br /><br /> 
		En tant que villageois, nous jouons en vue subjective et nous n'avons aucune arme. Il faut simplement se cacher et fuir le démon. <br/>
		Un indicateur textuel et une musique dynamique permet de savoir si le démon se trouve près de nous ou non. Plus la musique est stressante, plus il devient urgent de fuir. <br /> 
		
		En tant que démon, le jeu se joue à la 3ème personne. Nous disposons de deux attaques ainsi que d'un "radar" permettant de trouver les villageois. <br/> <br/> 
		
		Au niveau du développement, je me suis occupé d'un bon nombre d'éléments de gameplay. <br /> 
		Tout d'abord, les contrôles pour le joueur humain et démon, ensuite des IA simplistes : <br /> 
		Un villageois IA va choisir un point de passage sur la map et s'y diriger. S'il croise le démon en chemin, il va fuir dans la direction opposée vers un autre point de passage. <br /> 
		Le démon IA va choisir un des villageois au hasard et se diriger vers lui, s'il en croise un autre il va le prendre en chasse jusqu'à la mort ou jusqu'à ce qu'il soit trop loin (à ce moment il choisir à nouveau un villageois à poursuivre). <br /> 
		
		La musique / texte dynamique est une autre feature que j'ai développée et qui permet de jouer un son de plus en plus stressant avec un texte qui change selon la proximité du démon. <br />
		Aussi, lorsqu'un villageois meurt, un texte apparaît pour prévenir le joueur. Lorsqu'il reste peu de survivants, ou peu de temps au chronomètre, une musique lugubre se déclenche, et lorsqu'il ne reste qu'un humain, une musique métal se joue. <br />
		Enfin, si les humains survivent jusquà l'aube, une autre musique metal est jouée pour donner un peu d'adrenaline ! <br />
		
		À côté de cela, je me suis occupé aussi de l'interface et des menus du jeu. <br />

	]]>
	</description>
	
	<description lang="en">
	<![CDATA[
		Daynight Killer is a small game made during the game design course at UQAC. <br />
		It's an asymetrical survival game that we've made in a group of three, using Unity. <br />
		
		A demon is lurking in a village during a night (a few minutes in-game). Villagers have to hide and survive until dawn, when they'll get magical powers to help them defeat the demon. <br /><br /> 
		
		You can play as one of the villagers (others are AI-controlled) or as the demon.  <br />
		As a villager, the game is played in a first person perspective. You have no weapon, and you must run and avoid the demon. <br />
		A text cue and a dynamic music will warn you if the demon gets close, in which case you'll have to run !  <br />
		
		As the demon, the game is played in a third person perspective. You have two attacks (slap and bash) and you can sense the presence of your victims thanks to a "radar". <br /><br />
		
		My work covered a lot of gameplay elements. <br />
		First, the basic controls (FPS / TPS) and AI's behaviour.<br />
		The AI villagers are quite basic, they just choose a random waypoint on the map and head to it. If they come across the demon on their way, they'll pull back to another waypoint in the opposite direction. <br />
		If they are far enough from the demon, they'll wait a few seconds (to mimic a hiding stance) and choose another waypoint to go. <br />
		The AI demon will choose a random target and chase him. If he comes across another villager, he will follow the latter until he kills him or until he's too far (he will then choose another victim). <br /><br />
		
		Dynamic music / text is another feature that I have developped and that allows to play a sound that gets more and more intense, with a text that changes, depending on how far the demon is. <br />
		Also, when a villager dies, a text pops in to warn the player. When few villagers are alive, a creepy music starts playing, and when there is only one last human, a metal music starts. <br />
		If there are still humans at dawn, another pumping metal music is played, and the hunt for the demon can begin ! <br />
		
		Besides those gameplay points, I've also worked on the UI / menus.
	]]>
	</description>
	
	<links>
		<link name="github">https://github.com/yannismrad/DayNightKiller</link>
		<link name="youtube"></link>
	</links>
</project>

<!--super shoot land -->
<project id="ssl">
	<name>Super Shoot Land</name>
	<image>images/work/ssl.png</image>
	<screenshots>
		<screenshotImg>images/screenshots/ssl/0.png</screenshotImg>
		<screenshotImg>images/screenshots/ssl/1.png</screenshotImg>
		<screenshotImg>images/screenshots/ssl/2.png</screenshotImg>
	</screenshots>
	
	<description lang="fr">
	<![CDATA[
		Jeu développé dans le cadre du cours de Programmation orientée objet à l'UQAC.
		<br />Il s'agit d'un jeu de plateforme / shooter inspiré de Super Smash Land développé en Java avec la librairie JSFML.

		<br/> J'ai travaillé principalement sur la gestion des inputs :
	
		<ul class="bulletedlist">
			<li>Binding de touches via un parsing de fichier XML de configuration</li>
			<li>Gestion des touches pour deux joueurs</li>	
			<li>Wrapper pour simplifier l'accès aux inputs JSFML pour vérifier les actions des joueurs</li>
		</ul>
	]]>
	</description>
	
	<description lang="en">
	<![CDATA[
		Game developed for the Object Oriented Programming course at the UQAC.
		<br />It's a platformer/shooter Java game inspired from Super Smash Land, it uses the JSFML library.
		<br/>I have mainly worked on the input management :

		<ul class="bulletedlist">
			<li>Key binding through a parsed XML configuration file</li>
			<li>Two players key bindings</li>
			<li>Wrapper classes to ease the players' actions checking</li>		
		</ul>
	]]>
	</description>
	
	<links>
		<link name="github">https://github.com/FuriousCatInteractive/Super-Shoot-Land</link>
		<link name="youtube"></link>
	</links>
</project>

<!--halo monitor defense-->
<project id="hmd">
	<name>Halo Monitor Defense</name>
	<image>images/work/hmd.png</image>
	<screenshots></screenshots>
	
	<description lang="fr">
	<![CDATA[
		Projet de fin d'année réalisé durant ma licence en informatique à l'Université de Limoges. 
		L'objectif était de réaliser une application mobile en 3D, sous une forme de notre choix.
		Il s'agit ici d'un prototype de Tower Defense que j'ai développé seul sur Android à l'aide d'OpenGL ES et de la librairie JPCT-AE.
		
		Étant un grand fan de Halo, j'ai voulu m'inspirer de son univers pour créer ce petit jeu. <br /><br />
		
		J'avais dans un premier temps travaillé avec JPCT-AE pour générer toute la partie graphique du jeu (le sol, les différents types de tours, les textures, les sprites des ennemis etc).<br />
		Les ennemis étaient générés à partir d'un fichier XML où l'on pouvait configurer chaque vague pour y mettre les types d'ennemis désirés avec la quantité désirée. <br />
		Leur pathfinding était relativement basique puisque le chemin était composé de blocs. Lorsqu'un ennemi arrive vers un bloc, il va ensuite se diriger vers le bloc voisin et ainsi de suite jusqu'à la fin (le chemin est une liste chaînée de blocs). <br /><br />
		
		Pour construire des tours, il faut toucher un emplacement dédié près du chemin (des blocs de construction pré-établis), un menu s'ouvre alors et permet de choisir un type de tour (attaque rapide, attaque de zone etc) <br />
		La détection des ennemis par les tours se fait de la manière suivante : le bloc de construction sur lequel est posé la tour est associé à des blocs du chemin, ce qui détermine la portée de tir. <br />
		Par exemple, si la portée d'une tour est de 3, cela signifie que les 3 blocs de chemins adjacents au bloc de construction seront atteignables par des tirs. <br />
		Lorsqu'un ennemi rentre dans la portée, la tour commence à tirer et ne s'arrête que si l'ennemi meurt ou sort de sa portée de tir. <br />
		
	]]>
	</description>
	
	<description lang="en">
	<![CDATA[
		This is a small 3D tower defense game I have made during my bachelor's degree in computer science at the University of Limoges.<br />
		I developed it for Android platforms, using OpenGL ES and the JPCT-AE library.<br />
		
		As a big fan of the Halo games, I wanted to take inspiration from its lore to create this small game. <br /><br />
		
		First, I have worked with JPCT-AE for to generate the graphical part of the game (textures, ground, towers, sprites etc) <br />
		Ennemies were generated using an XML file in which we could configure each wave (which type of enemies, how many of them would spawn). <br />
		Pathfinding was pretty much basic as the path was composed of blocks. When an enemy steps on a block, it will head to the neighbour block, and so on until the end. The path is a linked-list of blocks where each block knows the next one. <br /><br />
		
		To build towers, one has to touch a dedicated building block next to the path, a menu pops in and allows you to choose a type of tower (rapid fire, area of damage etc). <br />
		Enemy detection is done this way : the building block on which a tower is built is linked to a set of blocks on the path, which defines its firing range. <br />
		For instance, if the range is 3, that means that the three path blocks adjacent to the building block will be reachable. <br />
		When an enemy gets in range, the tower starts shooting and stops only if he is dead or if he gets out of range. <br />
		 
	]]>
	</description>
	<links>		
	<link name="github">https://github.com/yannismrad/HaloMonitorDefense</link>
	<link name="youtube"></link>
	</links>
	</project>
	
	<!--"Default" project (for wrong urls) -->
	<project id="error">
		<name>?</name>
		<description lang="en">
			Project not found !
		</description>
		<description lang="fr">
			Ce projet n'existe pas !
		</description>
		
		<links>
			<link name="github"></link>
			<link name="youtube"></link>
		</links>
	</project>

</projects>